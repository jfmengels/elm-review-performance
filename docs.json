[{"name":"NoUnoptimizedRecursion","comment":"\n\n@docs rule\n\nTail-call optimization makes Elm code more performant and helps prevent stack overflows.\n\nSince this optimization is done silently and under specific circumstances, it is unfortunately relatively easy\nto not notice when the optimization has not been applied. You can find the [reasons why a function would not be optimized below](#fail).\n\n\n## Configuration\n\n@docs Configuration, optOutWithComment, optInWithComment\n\n\n## When (not) to enable this rule\n\nThis rule is useful for both application maintainers and package authors to detect locations where\nperformance could be improved and where stack overflows can happen.\n\nYou should not enable this rule if you do not care about performance at this point in time.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-performance/example --rules NoUnoptimizedRecursion\n```\n\nThe rule uses `optOutWithComment \"IGNORE TCO\"` as its configuration.\n\n\n## Success\n\nNot reported because it is tail-call optimized.\n\n    fun n =\n        if condition n then\n            fun (n - 1)\n\n        else\n            n\n\nNot reported because the function has been tagged as ignored.\n\n    -- With opt-out configuration\n    config =\n        [ NoUnoptimizedRecursion.rule (NoUnoptimizedRecursion.optOutWithComment \"IGNORE TCO\")\n        ]\n\n    fun n =\n        -- elm-review: IGNORE TCO\n        fun n * n\n\nNot reported because the function has not been tagged.\n\n    -- With opt-in configuration\n    config =\n        [ NoUnoptimizedRecursion.rule (NoUnoptimizedRecursion.optInWithComment \"CHECK TCO\")\n        ]\n\n    fun n =\n        fun n * n\n\n\n## Fail\n\nTo understand when a function would not get tail-call optimized, it is important to understand when it would be optimized.\n\nThe Elm compiler is able to do tail-call elimination **only** when all the recursive calls are the last operation that the function would do in that branch. Any recursive calls not happening in those locations de-optimizes the function.\n\nHere are the locations when a recursive call may happen in:\n\n  - branches of an if expression\n  - branches of a case expression\n  - in the body of a let expression (but not the functions)\n\nonly if each of the above appeared at the root of the function or in one of the above locations themselves.\n\nAlso to note: functions declared in a let function can be tail-call optimized.\n\nFollowing is a list of likely situations that will be reported.\n\n\n### An operation is applied on the result of a function call\n\nThe result of this function gets multiplied by `n`, making the recursive call not the last thing to happen in this branch.\n\n    factorial : Int -> Int\n    factorial n =\n        if n <= 1 then\n            1\n\n        else\n            factorial (n - 1) * n\n\nHint: When you need to apply a function on the result of a recursive call, what you can often do is to add an argument holding the result value and apply the operations on it instead.\n\n    factorialHelp : Int -> Int -> Int\n    factorialHelp n result =\n        if n <= 1 then\n            result\n\n        else\n            factorial (result * n) * n\n\nAnd split the function into the one that will do recursive calls (above) and a \"public-facing\" function which will set the initial result value (below).\n\n    factorial : Int -> Int\n    factorial n =\n        factorialHelp n 1\n\n\n### Calls using the |> or <| operators\n\nThe following won't be optimized. The fix here is very easy, as you only need to remove the operator and use parentheses instead.\n\n    fun n =\n        if condition n then\n            fun <| n - 1\n\n        else\n            n\n    fun n =\n        if condition n then\n            (n - 1)\n                |> fun\n\n        else\n            n\n\n\n### Calls appearing in || or && conditions\n\nThe following won't be optimized.\n\n    isPrefixOf : List a -> List a -> Bool\n    isPrefixOf prefix list =\n        case ( prefix, list ) of\n            ( [], _ ) ->\n                True\n\n            ( _ :: _, [] ) ->\n                False\n\n            ( p :: ps, x :: xs ) ->\n                p == x && isPrefixOf ps xs\n\nThe fix here is very easy, as you only need to use if expressions instead.\n\n    isPrefixOf : List a -> List a -> Bool\n    isPrefixOf prefix list =\n        case ( prefix, list ) of\n            ( [], _ ) ->\n                True\n\n            ( _ :: _, [] ) ->\n                False\n\n            ( p :: ps, x :: xs ) ->\n                if p == x then\n                    isPrefixOf ps xs\n\n                else\n                    False\n\n\n### Calls from let declarations\n\n    fun n =\n        let\n            funHelp y =\n                fun (y - 1)\n        in\n        funHelp n\n\n","unions":[{"name":"Configuration","comment":" Configuration for `NoUnoptimizedRecursion`.\n\nUse [`optOutWithComment`](#optOutWithComment) or [`optInWithComment`](#optInWithComment) to configure this rule.\n\nYou can use comments to say that a function should or should not be checked, depending on the configuration method you chose.\nThis comment has to appear on the line after the `=` that follows the declaration of your function, and will not report the function.\nThe same will apply for functions defined in a let expression.\n\nI recommend toggling between the two configuration options while you're fixing/ignoring the existing issues, and to use the\nopt-out configuration afterwards.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"optInWithComment","comment":" Reports only the functions tagged with a comment.\n\n    config =\n        [ NoUnoptimizedRecursion.rule (NoUnoptimizedRecursion.optInWithComment \"CHECK TCO\")\n        ]\n\nWith the configuration above, the following function would be reported.\n\n    fun n =\n        -- CHECK TCO\n        if condition n then\n            fun n * n\n\n        else\n            n\n\n","type":"String.String -> NoUnoptimizedRecursion.Configuration"},{"name":"optOutWithComment","comment":" Reports recursive functions by default, opt out functions tagged with a comment.\n\nI recommend to **not** default to ignoring a reported issue when something gets reported,\nand to discuss with your colleagues how to best solve the problem when you encounter the\nissue or when you see them ignore an error.\n\n    config =\n        [ NoUnoptimizedRecursion.rule (NoUnoptimizedRecursion.optOutWithComment \"IGNORE TCO\")\n        ]\n\nWith the configuration above, the following function would **not** be reported.\n\n    fun n =\n        -- elm-review: IGNORE TCO\n        if condition n then\n            fun n * n\n\n        else\n            n\n\n","type":"String.String -> NoUnoptimizedRecursion.Configuration"},{"name":"rule","comment":" Reports recursive functions that are not [tail-call optimized](https://functional-programming-in-elm.netlify.app/recursion/tail-call-elimination.html).\n","type":"NoUnoptimizedRecursion.Configuration -> Review.Rule.Rule"}],"binops":[]}]